# Prepopulated directives for flows-function-demo UI
# Format: one directive per line. Lines starting with # are comments.
# You can edit this file and click "Reload" in the picker.

# --- Baseline ---
sum of squares 1 through 10000
sum of cubes 1 through 5000
sum of fourth powers 1 through 2000
sum of fifth powers 1 through 1000
compute the variance of numbers 1 through 500 inclusive
compute the standard deviation of numbers 1 through 500 inclusive
sum the first 50 fibonacci numbers
compute the 45th fibonacci number
sum of factorials 1 through 12
sum of factorial reciprocals 1 through 20
count primes up to 10000
sum primes up to 20000
harmonic number 20000
sum of reciprocals of squares 1 through 20000
sum of 1 over fourth powers 1 through 5000
sum of 1 over cubes 1 through 10000
alternating harmonic sum 1 through 10000
approximate natural log of 2 using alternating harmonic 1 through 15000
approximate e using series 10 terms
approximate e using series 30 terms
approximate e using series 50 terms
approximate pi via leibniz 800000 terms
approximate pi via leibniz 1200000 terms
approximate pi via nilakantha 600000 terms
approximate pi via nilakantha 900000 terms
sum of squares of even numbers 2 through 5000
sum of cubes of odd numbers 1 through 4001
sum of triangular numbers 1 through 2000
sum of pentagonal numbers 1 through 1200
sum of squares of multiples of 3 up to 6000
alternating sum of squares 1 through 4000
alternating sum of cubes 1 through 2000
sum of reciprocals of squares of even numbers 2 through 10000
sum of reciprocals of squares of odd numbers 1 through 10001
approximate sqrt of 2 using 25 iterations of Newton method
compute the mean of squares of numbers 1 through 5000
sum of squares 10001 through 20000
sum of cubes 5001 through 10000
sum the first 120 natural numbers
alternating sum of reciprocals of squares 1 through 15000

# --- More complex ---
sum of sixth powers 1 through 120
sum of seventh powers 1 through 80
sum of fourth powers 1 through 1000
sum of fifth powers 1 through 300
sum of fourth powers of even numbers 2 through 1000
sum of reciprocals of squares 1 through 100000
sum of 1 over fourth powers 1 through 50000
sum of 1 over cubes 1 through 50000
approximate e using series 100 terms
approximate pi via leibniz 1000000 terms
approximate pi via leibniz 1500000 terms
approximate pi via nilakantha 800000 terms
approximate pi via nilakantha 1200000 terms
alternating sum of squares 1 through 5000
sum of squares of primes up to 5000
count primes up to 50000
sum of primes up to 20000

# --- Advanced exploratory ---
Multi-phase hybrid search: Find the smallest n < 80_000_000 such that (a) n is square-free, (b) the Collatz stopping time of n exceeds 600, and (c) the sum of distinct prime factors of n is a Fibonacci number > 1000. Return n and all intermediate factorization + stopping time metrics.
Adaptive gap analysis: Scan 1..120_000_000 to locate the first run of 9 consecutive composite numbers whose largest prime factor strictly decreases across the run, then verify a secondary condition: the product of the run’s endpoints has exactly 12 prime factors (with multiplicity). Return the run, its largest factors sequence, and the validation proof.
Branching evaluator synthesis: Enumerate n in 1..50_000_000 and classify each into one of three dynamic classes: (A) high Möbius volatility window (absolute sum of μ(k) over k∈[n, n+400] > 160), (B) abundant but not highly composite, (C) neither. For each class A candidate also compute its minimal totient ratio φ(n)/n neighborhood min over ±300. Return top 15 class A with supporting metrics.
Recursive structural chain length: Find the maximum length (and witness n ≤ 30_000_000) of the chain generated by repeatedly applying: if n divisible by 6 then n = n/6 else if n mod 6 = 1 then n = 5n+1 else n = 3n+5; terminate when reaching a previously seen value or 1. Track cycle detection. Return n, length, and the distinct value count before termination.
Dual strategy prime cluster detection: Detect the earliest interval [x, x+30_000] with x < 200_000_000 containing at least 18 primes whose pairwise gaps (sorted) form a strictly convex sequence (second differences all positive). Use a coarse shard scan; if shard hints ≥ threshold density, switch to fine sieve within that shard. Return x, the primes, gap list, and convexity proof.
Multiobjective extremum search: Over 1..90_000_000 find the top 10 n maximizing score(n) = (sigma(n)/n) * (collatz_steps(n) / log2(n)) subject to: n squareful OR (number of distinct prime factors ≥ 5 AND largest prime factor − smallest prime factor > 10_000). Provide sorted list with decompositions and component metrics.
Deep branching range refinement: Locate all n ≤ 60_000_000 where both n and n+2 are composite but φ(n+2) − φ(n) is prime and the count of prime divisors of (n*(n+2)) is 9. Use an early elimination evaluator; for survivors compute exact totients. Return first 40 matches with factor summaries.
Meta-plan repair stress: Search n ≤ 40_000_000 for numbers whose binary representation has exactly 17 runs (alternating sequences of 0s/1s), the number of 1 bits is prime, and reversing the decimal digits yields a number with a larger Collatz stopping time by at least 50. Return first 25 plus metrics.
Layered evaluator cascade: Enumerate k ≤ 55_000_000; define f(k) = repetition count until k becomes 1 by applying: if k ≡ 0 (mod 4) then k = k/4 else if k ≡ 2 (mod 4) then k = 3k+2 else k = 5k+1. Gather k where f(k) > 500 and (k has exactly 3 prime factors OR k is twice a perfect square). Return maximum f(k) and 20 witnesses.
Hybrid function + execution graph integration: Compute over 1..25_000_000 the set S of n where sum_{d|n} μ(d)^2 = 2^{ω(n)} (i.e. square-free check) and simultaneously the reversed Collatz variant (if n odd: n = 2n+1 else n = n/2) hits a value < 50 in < 40 steps. Provide top 50 n with ω(n), step counts, and terminal value.
